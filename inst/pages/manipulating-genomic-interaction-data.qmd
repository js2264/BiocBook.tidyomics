# Manipulating genomic interaction data

## What are `GInteractions`? 

*Recommended time: 15 min*

### Creating a `GInteractions` object from scratch

`GInteractions` class of object combines pairs of interacting `GRanges` together. It is defined by the `InteractionSet` package. 

Each side of the pair is referred to as "anchors" (e.g. `anchors1` and `anchors2` refer to left-hand and right-hand side of the genomic interaction). 

```{r eval = FALSE}
library(InteractionSet)

gr1 <- GRanges("I:10-50")

gr2 <- GRanges("I:100-110")

GInteractions(anchor1 = gr1, anchor2 = gr2)
```

A `GInteractions` object can also be generated by specific a set of `regions` (as a `GRanges` object with multiple entries)
and a set of numerical indices linking the different regions by pairs. 

```{r eval = FALSE}
GInteractions(anchor1 = c(1, 2, 3), anchor2 = c(1, 4, 5), regions = gr)
```

### Importing genomic interaction data from files

A `GInteractions` object is typically imported in R from a file storing 
genomic interactions, e.g. a `bedpe` file or a `pairs` file, using the 
`as_ginteractions()` coercing function from the `plyinteractions` package.

```{r eval = FALSE}
bedpef <- system.file('extdata', 'S288C-loops.bedpe', package = 'Bioc2024tidyWorkshop', mustWork = TRUE)

tib <- read_tsv(bedpef, col_names = FALSE) 

tib

library(plyinteractions)

gi <- tib |> 
    as_ginteractions(
        seqnames1 = X1, start1 = X2, end1 = X3, 
        seqnames2 = X4, start2 = X5, end2 = X6
    )

gi
```

## Manipulating `GInteractions` the tidy way

*Recommended time: 15 min*

### Moving anchors around

Just like `GRanges`, one can mutate columns, including "protected" columns, 
including `seqnames{12}`, `start{12}`, `end{12}`, `strand{12}` and `width{12}`. 

```{r eval = FALSE}
gi |> 
    mutate(
        seqnames1 = factor('XVI', levels(seqnames1)), 
        strand1 = '+', 
        start2 = end1, 
        width2 = width1 + 100, 
        score = runif(length(gi)), 
        is_cis = ifelse(seqnames1 == seqnames2, TRUE, FALSE)
    )
```

### Filtering interactions

Here again, the `filter()` function can operate on `GInteractions` objects 
to filter entries using a boolean condition. 

```{r eval = FALSE}
gi |> filter(seqnames1 == 'I')

gi |> filter(seqnames2 == 'I')

gi |> 
    mutate(score = runif(length(gi))) |> 
    filter(seqnames2 == 'I', score > 0.2)
```

### Overlapping anchors

`join_overlap_left()` function defined in `plyranges` package has been adapted
to work with 

```{r eval = FALSE}
centros <- system.file('extdata', 'col', package = 'Bioc2024tidyWorkshop', mustWork = TRUE) |> 
    read_tsv() |> 
    as_granges(seqnames = seqID) |> 
    anchor_center() |> 
    stretch(20000)

gi |> 
    join_overlap_left(centros) |> 
    filter(!is.na(patternName))
```

`pin_anchors{12}` functions can be used to restrict the overlap function to 
only one or the other anchor of each interaction.

```{r eval = FALSE}
gi |> 
    pin_anchors1() |> 
    join_overlap_left(centros) |> 
    filter(!is.na(patternName))

gi |> 
    pin_anchors2() |> 
    join_overlap_left(centros) |> 
    filter(!is.na(patternName))
```

## Real-world use case: computing a P(s)

*Recommended time: 20 min*

### Importing data from pairs file

Let's first import pairs as a `tibble`, then coerce them into `GInterctions`.  
The `mESCs.pairs.gz` example dataset is provided by the workshop package. 

```{r eval = FALSE}
pairsf <- system.file('extdata', 'mESCs.pairs.gz', package = 'Bioc2024tidyWorkshop', mustWork = TRUE)

pairs <- read_tsv(pairsf, col_names = FALSE, comment = "#") |> 
    set_names(c(
        "ID", "seqnames1", "start1", "seqnames2", "start2", "strand1", "strand2"
    )) |> 
    as_ginteractions(end1 = start1, end2 = start2, keep.extra.columns = TRUE)
```

### Counting interactions by strands

We can get insights in the short-scale genomic-distance-dependent frequency of pairs 
according to their strand combination. 

```{r eval = FALSE}
df <- pairs |> 
    add_pairdist() |> 
    filter(pairdist < 2000) |> 
    group_by(strand1, strand2, pairdist) |> 
    count() 

ggplot(df, aes(x = pairdist, y = n, col = interaction(strand1, strand2))) + 
    geom_smooth() + 
    scale_y_log10()
```

### Plot P(s)

More generally, we can compute genome-wide genomic-distance-dependent interaction frequency, or P(s). 

```{r eval = FALSE}
x <- 1.1^(1:200-1)
lmc <- coef(lm(c(1,1161443398)~c(x[1], x[200])))
bins_breaks <- unique(round(lmc[2]*x + lmc[1]))
bins_widths <- lead(bins_breaks) - bins_breaks

# Bin distances
df <- pairs |> 
    add_pairdist(colname = 's') |> 
    mutate(
        binned_s = bins_breaks[as.numeric(cut(s, bins_breaks))], 
        bin_width = bins_widths[as.numeric(cut(s, bins_breaks))]
    ) |> 
    group_by(binned_s, bin_width) |> 
    count(name = "n") |>
    as_tibble() |> 
    mutate(Ps = n / sum(n) / bin_width)
    
ggplot(df, aes(x = binned_s, y = Ps)) + 
    geom_line() + 
    scale_y_log10() +
    scale_x_log10() +
    annotation_logticks() + 
    labs(x = "Genomic distance", y = "Contact frequency") + 
    theme_bw()
```

## Resources {-}


## Session info {-}

::: {.callout-note collapse="true"}

## Click to expand ðŸ‘‡

```{r "session info"}
#| cache: false
sessioninfo::session_info(
    installed.packages()[,"Package"], 
    include_base = TRUE
)
```

:::
